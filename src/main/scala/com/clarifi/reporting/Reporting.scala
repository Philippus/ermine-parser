package com.clarifi.reporting

import java.util.Date
import java.util.UUID

import scalaz._
import Scalaz._
import Equal._
import Show._
import Ordering._
import Order._
import IterV._

import com.clarifi.reporting.PrimT._

  /*def map(f: A => B, inString: String => A, outString: B => String,
                     inDouble: Double => A, outDouble: B => Double,
                     inByte: Byte => A, outByte: B => Byte,
                     inShort: Short => A, outShort: B => Short,
                     inInt: Int => A, outInt: B => Int,
                     inLong: Long => A, outLong: B => Long,
                     inDate: Date => A, outDate: B => Date,
                     inBoolean: Boolean => A, outBoolean: B => Boolean,
                     inUUID: UUID => A, outUUID: B => UUID
                   ): PrimExpr = this match {
    case StringExpr(n, s) => outString(f(inString(s)))
    case DoubleExpr(n, d) => outDouble(f(inDouble(d)))
    case ByteExpr(n, d) => outByte(f(inByte(d)))
    case ShortExpr(n, d) => outShort(f(inShort(d)))
    case LongExpr(n, d) => outLong(f(inLong(d)))
    case IntExpr(n, i) => outInt(f(inInt(i)))
    case DateExpr(n, d) => outDate(f(inDate(d)))
    case BooleanExpr(n, b) => outBoolean(f(inBoolean(b)))
    case UuidExpr(n, u) => outUUID(f(inUUID(u)))
    case x => x
  }*/
object Reporting {
  /** A reference ID generated by a raw data backend */
  sealed trait RefIDTag
  type RefID = String @@ RefIDTag
  def RefID(value: String): RefID = Tag[String, RefIDTag](value)

  sealed trait DynT
  type Dyn = Any @@ DynT
  def Dyn(value: Any): Dyn = Tag[Any, DynT](value)

  // Pattern for non-empty lists
  object NEL { def unapply[A](n: NonEmptyList[A]): Option[(A, List[A])] = Some((n.head, n.tail)) }

  type RefHandler[M[_]] = ({type f[x] = (RefID, IterV[Record, x])})#f ~> ({type f[x] = M[IterV[Record, x]]})#f

  // Show, Equal, and Order instances
  implicit val RefIDShow: Show[RefID] = showFromToString[String] contramap (_.toString)
  implicit val RefIDEqual: Equal[RefID] = equalA[String] contramap (_.toString)
  implicit val DynShow: Show[Dyn] = showFromToString[Any] contramap (_.toString)
  implicit val DynEqual: Equal[Dyn] = equalA[Any] contramap (x => x : Any)
  implicit val AttributeEqual: Equal[Attribute] = equal((a, b) => a.name === b.name && a.t == b.t)
  implicit val AttributeShow: Show[Attribute] = show(a => (a.name, a.t).show)
  implicit def MapShow[K,V] = showFromToString[Map[K,V]]

  implicit val DateShow = showFromToString[Date]
  implicit val DateEqual = equalA[Date]
  implicit val DateOrder: Order[Date] = order((a, b) => a.getTime ?|? b.getTime)
  implicit val DateOrdering: scala.math.Ordering[Date] = new scala.math.Ordering[Date] {
    def compare(d1: Date, d2: Date): Int = (d1.getTime - d2.getTime).asInstanceOf[Int]
  }

  implicit val UuidOrder: Order[UUID] = order((a, b) => a compareTo b match {
    case -1 => LT
    case 0 => EQ
    case 1 => GT
  })

  implicit val UuidShow = showFromToString[UUID]
  implicit val UuidEqual = equalA[UUID]
  implicit val UuidOrdering: scala.math.Ordering[UUID] = new scala.math.Ordering[UUID] {
    def compare(d1: UUID, d2: UUID): Int = d1 compareTo d2
  }

  implicit def refIDToTableName(r: RefID): TableName =
    TableName(r.toString, Nil)

  type DataSetT[M[+_]] = StreamT[M, (TableName, Record)]
  type DataSetS[S] = DataSetT[({type M[+X] = State[S, X]})#M]
  type DataSet = DataSetT[Id]
  type SimpleDataSet = StreamT[Id, (String, Record)]

  def TypeError(s: String): TypeError = List(s)

  def alignMap[K,V,V2,V3](m: Map[K,V], m2: Map[K,V2])(oneL: V => V3, oneR: V2 => V3, both: (V,V2) => V3): Map[K,V3] =
    m.transform((k,v) => m2.get(k) map (v2 => both(v,v2)) getOrElse oneL(v)) ++
    (m2 -- m.keySet).mapValues(oneR)

}

